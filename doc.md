# INIParse 解析文档

## 简介
很多的时候为了使程序能适应多种情况。需要从程序外部获取一些变量，比如命令行参数，数据库，配置文件等方式来获取外部变量，来增强程序的适应性。在这几种方式里面，数据库的方式依赖第三方程序，依赖性强；明航参数在表现力和扩展性上较弱；对比下来，配置文件是一个不错的外部变量交互方式。

### 配置文件的格式
配置文件目前有 XML, JSON, YAML, .properties, INI 等主流的配置文件格式。因为不同语言，开发场景等还有会有其他的格式，比如 PHP 开发一般都是直接使用 PHP 文件作为配置文件的格式。但是拥有这种语言级别的特性的还是少数。
配置文件在给程序提供外部变量的同时，有时还会遇到多语言场景，比如同样的配置文件需要能在多中编程语言中能够良好的解析。所以优秀的配置文件格式是在各种语言中都能得到很好的支持。
还有，在很多场景下，配置文件是通过手写来完成的，对手写友好，比如兼容一点的错误，支持重复内容的抽象，变量的支持，注释等特性
所以，一个优秀的配置文件格式，语法，能跨语言解析，对手写友好是很重要的。
XML 作为一个久经考验的配置文件格式，表现力，编程语言支持等方面都是很优秀的。但是如果手写 XML 却是很麻烦的。虽然已经有 XML 生成器，但是手写的场景依然很多。而且 XML 的表现力很强，但是副作用就是语法灵活，复杂。基本上每个程序，都要遵守一下自己的嵌套规则。

JSON 格式语法灵活，表现力强，手写相对 XML 来说也方便很多，并且在语言支持层面也很不错。但是很多解析器是不支持注释的，配置文件里面添加注释有助益帮助维护和了解程序的。无法在配置文件里面添加注释就不能方便的了解内容的用处。

YAML 支持注释，但是在书写的时候，需要遵守严格的缩进关系来表示结构的层次关系。这样的话就降低了对格式的容错能力，而手写的过程也经常会出一些缩进的错误，造成无法正确解析。当然 YAML 也支持 JSON 格式的书写方式，用`{}``[]` 来表示结构层次关系。这么看来，YAML是一个优秀的配置文件格式。

.properties, INI 语法很相似，支持注释，格式语法简单，极易学习和书写。都是 key-value 形式的，且 INI 还有 `[]` 来表示层级。但是这样话，层级嵌套只支持两级，且想要表达一个列表的时候无法表达。虽然有很多解析器都对这两点有提供额外的支持，但是不同的解析器却有着千差万别的差异。

以上我们了解了各种配置文件特点。那我们在了解一下我们使用配置文件的场景。
1.  配置文件避免不了要手写的需求，手写就避免不了一些空格，缩进等方面的问题。所以这就需要对这些小问题的兼容。
2.  有时候我们会对多个使用场景下使用多个配置文件，而多个配置文件之间仅仅部分地方有差异，其他的都是一致的。所以可以对相同的部分单独保存早一个配置文件里面。如果解析器支持同时解析多个文件是可行的。但是这块逻辑需要在代码里面才能看到才能明白，如果在配置文件里面支持 include 操作，那么只看配置文件就能明白这块逻辑。
3.  配置型之间的关联，举个例子配置项A的值在配置项B里面这个值，且两者必须一致。或者值B的一部分是A值。所以如果配置语法支持变量替换那么就能很好的解决这个问题。

*写到这里我不想写了*
总结下来，一个优秀的配置文件格式需要有一下特性：
1.  支持注释
2.  对手写友好
3.  支持层级
4.  支持include
5.  支持变量替换
6.  语法简单，通用性强，易书写

那么这么看来就算 YAML 比较符合我们的要求了。但是YAML的在简单的场景下，还是略显臃肿……
如果我们简单扩展一下 INI 的语法是不是就可以满足我们的需求了呢？
举个例子

    ;main.ini
    [test]
    ;注释
    name = iniparse
    version = 1.0.0
    author[] = ma
    author[] = bao
    author[] = bo
    
    [test.history]
    ;更新记录
    
    ;变量替换
    version = %test.version%
    log = "提交了版本"
    long_log = "这次提交我们更新了很多内容\"
                "包括多个语言支持\"
                "支持了更多的类型"
    info = "%test.name% is a INIParse write by me"

这里面`;`开头的是注释。必须是一行都是注释。
如果 value 后面加上了`"`或者`'`单引号uozhe双引号包括了。那么就直接当作字符串去处理。如果没有被引号包括起来。那么解析器回去尝试进行类型转换。比如把类型转换成bool,int,float如果转换不了那就继续当作字符串处理。
如果key是以`[]` 结尾的，表示是个列表`list` 后面存在同样的key的情况不会发生覆盖，而是在value后面追加。
如果value结尾是 `\ ` 且下一行不包括`=`或其他分隔符，那么就当作是多行文件处理。
被`[]`包围的是表示分组，如果里面有`.`表示层级结构。比如上面的例子，转换城 JSON 表示就是

    {
        "test": 
        {
            "name":"iniparse",
            "version":"1.0.0",
            "authoe":[
                    "ma",
                    "bao",
                    "bo"
                ],
            "history": {
                "version":"1.0.0",
                "log: "提交了版本",
                "long_log": "这次提交我们更新了很多内容\n包括多个语言支持\n支持了更多的类型",
                "info": "iniparse is a INIParse write by me"
            }
        }
    }

这里包含了，变量替换和层级结构的表示。

如何表达include操作：

    ;test.ini
    @include "./main.ini"
    [test.other]
    version = %test.version%

配置里面出现的单独一行 `@include xxxx` 表示引入其他文件。做用等于把要要引入的文件内容复制到这里。和在一个文件里面没什么差异。
